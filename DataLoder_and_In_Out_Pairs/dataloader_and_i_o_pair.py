# -*- coding: utf-8 -*-
"""DataLoader and I/O Pair.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bVu7I85RAiZB5fGU1BTjQCAT6X6KgJvC

# Step 1: Creating Tokens

The print command prints the total number of characters followed by the first 100 characters of this file for illustration purposes.
"""

with open("alice_in_wonderland.txt", "r", encoding="utf-8") as f:
    raw_text = f.read()

print("Total number of character:", len(raw_text))
print(raw_text[:99])

"""Using some simple example text, we can use the re.split command with the following syntax to split a text on whitespace characters:"""

import re

text = "Hello, world. This, is a test."
result = re.split(r'(\s)', text)

print(result)

"""Using some simple example text, we can use the re.split command with the following syntax to split a text on whitespace characters:"""

import re

text = "Hello, world. This, is a test."
result = re.split(r'(\s)', text)

print(result)

"""Let's modify the regular expression (re) splits on whitespaces (\s) and commas, and periods ([,.]):



"""

result = re.split(r'([,.]|\s)', text)
print(result)

"""A small remaining issue is that the list still includes whitespace characters. Optionally, we can remove these redundant characters safely as follows:

"""

result = [item for item in result if item.strip()]      #  item.strip() :- Removing the WhiteSpaces
print(result)

""" Let's modify it a bit further so that it can also handle other types of punctuation, such as question marks, quotation marks, and the double-dashes we have seen earlier in the first 100 characters of Edith Wharton's short story, along with additional special characters:"""

text = "Hello, world. Is this-- a test?"
result = re.split(r'([,.:;?_!"()\']|--|\s)', text)
result = [item.strip() for item in result if item.strip()]
print(result)

# Strip whitespace from each item and then filter out any empty strings.
result = [item for item in result if item.strip()]
print(result)

"""## Now that we got a basic tokenizer working,"""

preprocessed = re.split(r'([,.:;?_!"()\']|--|\s)', raw_text)
preprocessed = [item.strip() for item in preprocessed if item.strip()]
print(preprocessed[:30])

print(len(preprocessed))

# if we want to remove the Numerical values form the Dataset then we can also do it here then after that creating the token id

"""# Step 2: Creating Token IDs

In the previous section, we tokenized a short story and assigned it to a Python variable called preprocessed. Let's now create a list of all unique tokens and sort them alphabetically to determine the vocabulary size:
"""

all_words = sorted(set(preprocessed))
vocab_size = len(all_words)

print(vocab_size)

"""After determining that the vocabulary size is 3189 via the above code, we create the vocabulary and print its first 51 entries for illustration purposes:"""

vocab = {token:integer for integer,token in enumerate(all_words)}   # assinning the token id to the vocab

for i, item in enumerate(vocab.items()):
    print(item)
    if i >= 50:
        break

"""Later in this book, when we want to convert the outputs of an LLM from numbers back into text, we also need a way to turn token IDs into text.

For this, we can create an inverse version of the vocabulary that maps token IDs back to corresponding text tokens.

### The class will have an encode method that splits text into tokens and carries out the string-to-integer mapping to produce token IDs via the vocabulary.
### In addition, we implement a decode method that carries out the reverse integer-to-string mapping to convert the token IDs back into text.
"""

# Step 1: Store the vocabulary as a class attribute for access in the encode and decode methods

# Step 2: Create an inverse vocabulary that maps token IDs back to the original text tokens

# Step 3: Process input text into token IDs

# Step 4: Convert token IDs back into text

# Step 5: Replace spaces before the specified punctuation

class SimpleTokenizerV1:
    def __init__(self, vocab):
        self.str_to_int = vocab
        self.int_to_str = {i:s for s,i in vocab.items()}

    def encode(self, text):
        preprocessed = re.split(r'([,.:;?_!"()\']|--|\s)', text)

        preprocessed = [
            item.strip() for item in preprocessed if item.strip()
        ]
        ids = [self.str_to_int[s] for s in preprocessed]
        return ids

    def decode(self, ids):
        text = " ".join([self.int_to_str[i] for i in ids])
        # Replace spaces before the specified punctuations
        text = re.sub(r'\s+([,.?!"()\'])', r'\1', text)
        return text

"""Let's instantiate a new tokenizer object from the SimpleTokenizerV1 try it out in practice:"""

tokenizer = SimpleTokenizerV1(vocab)

text = """"Alice's Adventures in Wonderland"""
ids = tokenizer.encode(text)
print(ids)

"""The code above prints the following token IDs: Next, let's see if we can turn these token IDs back into text using the decode method:"""

tokenizer.decode(ids)

text = "Hello, do you like tea?"   # Hello this word is not in the Txt file so this error is getting so we are ====> adding special context
print(tokenizer.encode(text))

"""## ADDING SPECIAL CONTEXT TOKENS"""

# In the previous section, we implemented a simple tokenizer and applied it to a passage from the training set.

# In this section, we will modify this tokenizer to handle unknown words.

# In particular, we will modify the vocabulary and tokenizer we implemented in the previous section, SimpleTokenizerV2
# to support two new tokens, <|unk|> and <|endoftext|>

"""Let's now modify the vocabulary to include these two special tokens, and <|endoftext|>, by adding these to the list of all unique words that we created in the previous section:"""

all_tokens = sorted(list(set(preprocessed)))
all_tokens.extend(["<|endoftext|>", "<|unk|>"])

vocab = {token:integer for integer,token in enumerate(all_tokens)}

len(vocab.items())

for i, item in enumerate(list(vocab.items())[-5:]):
    print(item)



"""Step 1: Replace unknown words by <|unk|> tokens

Step 2: Replace spaces before the specified punctuations
"""

class SimpleTokenizerV2:
    def __init__(self, vocab):
        self.str_to_int = vocab
        self.int_to_str = { i:s for s,i in vocab.items()}

    def encode(self, text):
        preprocessed = re.split(r'([,.:;?_!"()\']|--|\s)', text)
        preprocessed = [item.strip() for item in preprocessed if item.strip()]
        preprocessed = [
            item if item in self.str_to_int           # <===#
            else "<|unk|>" for item in preprocessed   # <===#
        ]

        ids = [self.str_to_int[s] for s in preprocessed]
        return ids

    def decode(self, ids):
        text = " ".join([self.int_to_str[i] for i in ids])
        # Replace spaces before the specified punctuations
        text = re.sub(r'\s+([,.:;?!"()\'])', r'\1', text)
        return text

tokenizer = SimpleTokenizerV2(vocab)

text1 = "Hello, do you like tea?"
text2 = "In the sunlit terraces of the palace."

text = " <|endoftext|> ".join((text1, text2))

print(text)

tokenizer.encode(text)

tokenizer.decode(tokenizer.encode(text))

"""# BPE (Byte Pair Encoding)

This section covers a more sophisticated tokenization scheme based on a concept called byte pair encoding (BPE).
The BPE tokenizer covered in this section was used to train LLMs such as GPT-2, GPT-3, and the original model used in ChatGPT.
"""

# https://github.com/openai/tiktoken

# Tiktoken (OpenAI’s GPT-4 / GPT-4o / GPT-4.5)
# GPT-4 and GPT-4o use tiktoken, OpenAI’s efficient tokenizer.

# Based on byte-level BPE, but highly optimized for speed & memory.

# Backward-compatible with GPT-3 vocabulary but faster.

# 1 > Word Based Tokenizer.
# 2 > Sub-Word Based Tokenizer.
# 3 > Charecter Wised Tokenizer.

"""The usage of this tokenizer is similar to SimpleTokenizerV2 we implemented previously via an encode method: https://github.com/PrashantTakale369/Transformer-Basics/blob/b0eb0d70b16f09b11f4c5e8bd99e803c8e51771e/Tokanizer/Tokanizer.ipynb"""

import importlib
import tiktoken

print("tiktoken version:", importlib.metadata.version("tiktoken"))

tokenizer = tiktoken.get_encoding("gpt2")

text = (
    "Hello, do you like tea? <|endoftext|> My name is Prashant someunknownPlace."
)

integers = tokenizer.encode(text, allowed_special={"<|endoftext|>"})

print(integers)

"""We can then convert the token IDs back into text using the decode method, similar to our SimpleTokenizerV2 earlier: https://github.com/PrashantTakale369/Transformer-Basics/blob/b0eb0d70b16f09b11f4c5e8bd99e803c8e51771e/Tokanizer/Tokanizer.ipynb"""

strings = tokenizer.decode(integers)
print(strings)

"""In fact, the BPE tokenizer, which was used to train models such as GPT-2, GPT-3, and the original model used in ChatGPT, has a total vocabulary size of 50,257, with <|endoftext|> being assigned the largest token ID.

Second, the BPE tokenizer above encodes and decodes unknown words, such as "someunknownPlace" correctly. The BPE tokenizer can handle any unknown word. How does it achieve this without using <|unk|> tokens?

*Lets Try on Diff meningless word *
"""

text = (
    "jjnd difn"
)

integers = tokenizer.encode(text, allowed_special={"<|endoftext|>"})

print(integers)

strings = tokenizer.decode(integers)
print(strings)

"""# Data Loader and Input Output Pairs

### CREATING INPUT-TARGET PAIRS
"""

# In this section we implement a data loader that fetches the input-target pairs using a sliding window approach.
# To get started, we will first tokenize the whole The Verdict short story we worked with earlier using the BPE tokenizer introduced in the previous section:

with open("alice_in_wonderland.txt", "r", encoding="utf-8") as f:
    raw_text = f.read()

enc_text = tokenizer.encode(raw_text)
print(len(enc_text))

enc_sample = enc_text[50:]

"""One of the easiest and most intuitive ways to create the input-target pairs for the nextword prediction task is to create two variables, x and y, where x contains the input tokens and y contains the targets, which are the inputs shifted by 1:"""

context_size = 4 #length of the input
#The context_size of 4 means that the model is trained to look at a sequence of 4 words (or tokens)
#to predict the next word in the sequence.
#The input x is the first 4 tokens [1, 2, 3, 4], and the target y is the next 4 tokens [2, 3, 4, 5]

x = enc_sample[:context_size]
y = enc_sample[1:context_size+1]

print(f"x: {x}")
print(f"y:      {y}")

"""Processing the inputs along with the targets, which are the inputs shifted by one position, we can then create the next-word prediction tasks as follows:"""

for i in range(1, context_size+1):
    context = enc_sample[:i]
    desired = enc_sample[i]

    print(context, "---->", desired)

"""For understanding purposes, let's repeat the previous code but convert the token IDs into text:"""

for i in range(1, context_size+1):
    context = enc_sample[:i]
    desired = enc_sample[i]

    print(tokenizer.decode(context), "---->", tokenizer.decode([desired]))

"""Now we need to ===>
implementing an efficient data loader that iterates over the input dataset and returns the inputs and targets as PyTorch tensors, which can be thought of as multidimensional arrays.

### IMPLEMENTING A DATA LOADER
"""

# Step 1: Tokenize the entire text
# Step 2: Use a sliding window to chunk the book into overlapping sequences of max_length
# Step 3: Return the total number of rows in the dataset
# Step 4: Return a single row from the dataset

from torch.utils.data import Dataset, DataLoader


class GPTDatasetV1(Dataset):
    def __init__(self, txt, tokenizer, max_length, stride):
        self.input_ids = []
        self.target_ids = []

        # Tokenize the entire text
        token_ids = tokenizer.encode(txt, allowed_special={"<|endoftext|>"})

        # Use a sliding window to chunk the book into overlapping sequences of max_length
        for i in range(0, len(token_ids) - max_length, stride):
            input_chunk = token_ids[i:i + max_length]
            target_chunk = token_ids[i + 1: i + max_length + 1]
            self.input_ids.append(torch.tensor(input_chunk))
            self.target_ids.append(torch.tensor(target_chunk))

    def __len__(self):
        return len(self.input_ids)

    def __getitem__(self, idx):
        return self.input_ids[idx], self.target_ids[idx]

"""Each row consists of a number of token IDs (based on a max_length) assigned to an input_chunk tensor.

The target_chunk tensor contains the corresponding targets.
"""

# Step 1: Initialize the tokenizer

# Step 2: Create dataset

# Step 3: drop_last=True drops the last batch if it is shorter than the specified batch_size to prevent loss spikes during training

# Step 4: The number of CPU processes to use for preprocessing

pip install tiktoken

def create_dataloader_v1(txt, batch_size=4, max_length=256,stride=128, shuffle=True, drop_last=True,num_workers=0):

    # Initialize the tokenizer
    tokenizer = tiktoken.get_encoding("gpt2")

    # Create dataset
    dataset = GPTDatasetV1(txt, tokenizer, max_length, stride)

    # Create dataloader
    dataloader = DataLoader(
        dataset,
        batch_size=batch_size,
        shuffle=shuffle,
        drop_last=drop_last,
        num_workers=num_workers
    )

    return dataloader

with open("alice_in_wonderland.txt", "r", encoding="utf-8") as f:
    raw_text = f.read()

"""Convert dataloader into a Python iterator to fetch the next entry via Python's built-in next() function"""

import tiktoken

import torch
print("PyTorch version:", torch.__version__)
dataloader = create_dataloader_v1(raw_text, batch_size=1, max_length=4, stride=1, shuffle=False)

data_iter = iter(dataloader)
first_batch = next(data_iter)
print(first_batch)

"""The first_batch variable contains two tensors: the first tensor stores the input token IDs, and the second tensor stores the target token IDs.
Since the max_length is set to 4, each of the two tensors contains 4 token IDs.
"""

# In mostly LLM Has 256 maxLength :- means it predict the next word after 256 word yes

""" creating the embedding vectors from the token IDs,"""

dataloader = create_dataloader_v1(raw_text, batch_size=8, max_length=4, stride=4, shuffle=False)

data_iter = iter(dataloader)
inputs, targets = next(data_iter)
print("Inputs:\n", inputs)
print("\nTargets:\n", targets)

